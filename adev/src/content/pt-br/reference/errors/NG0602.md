<!-- ia-translate: true -->
# Chamada de função não permitida dentro de contexto reativo

Uma função que não é permitida ser executada dentro de um contexto reativo foi chamada de dentro de um contexto reativo.

Por exemplo, um `effect` não pode ser agendado de dentro de um `computed` ou de um effect em execução ativa.
Evite chamar funções como `effect` como parte de expressões de template, pois elas são executadas em seu próprio contexto reativo.

Expressões computadas esperam-se ser puras.
Puro significa que a expressão não aciona nenhum efeito colateral.
Efeitos colaterais são operações como agendar `afterNextRender`/`afterEveryRender`, criar um novo `effect`, ou se inscrever em observables.

Algumas operações são explicitamente banidas dentro de contextos reativos para evitar armadilhas comuns.
Como exemplo, usar `afterNextRender`/`afterEveryRender` dentro de um `computed` irá agendar novos hooks de renderização toda vez que a expressão computada for avaliada.
Isso provavelmente não é intencional e pode degradar o desempenho da aplicação.

### Corrigindo o erro

Este guia de erro não é exaustivo.
Ele captura alguns cenários comuns e como abordar o erro.

#### `afterNextRender`/`afterEveryRender`

Mova a chamada para `afterNextRender`/`afterEveryRender` para fora do contexto reativo.

Um bom lugar para agendar o hook after render é no construtor da classe do component.
Alternativamente, use `untracked` para sair do contexto reativo e explicitamente optar por não receber este erro.

#### `effect`

Mova a chamada para `effect` para fora do contexto reativo.

Um bom lugar para agendar um effect é no construtor da classe de um `@Component`.

#### `toSignal`

Mova a chamada para `toSignal` para fora do contexto reativo.

```typescript
result = computed(() => {
  const dataSignal = toSignal(dataObservable$);
  return doSomething(dataSignal());
});
```

pode ser refatorado para:

```typescript
dataSignal = toSignal(dataObservable$);
result = computed(() => doSomething(dataSignal()));
```

Alternativamente, se isso não for possível, considere se inscrever manualmente no observable.

Como último recurso, use `untracked` para sair do contexto reativo.
Tenha cuidado, pois sair do contexto reativo pode resultar em leituras de signal sendo ignoradas dentro de `untracked`.

@debugging

A mensagem de erro menciona a função que foi chamada inesperadamente.
Procure por esta chamada de função no código da sua aplicação.

Alternativamente, o stack trace no seu navegador mostrará onde a função foi invocada e onde ela está localizada.
