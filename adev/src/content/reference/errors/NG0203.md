<!-- ia-translate: true -->
# `inject()` deve ser chamado de um contexto de injeção

Você vê este erro quando tenta usar a função [`inject`](api/core/inject) fora do [contexto de injeção](guide/di/dependency-injection-context) permitido. O contexto de injeção está disponível durante a criação e inicialização da classe. Também está disponível para funções usadas com `runInInjectionContext`.

Na prática, as chamadas `inject()` são permitidas em um constructor, um parâmetro de constructor e um inicializador de campo:

```typescript
@Injectable({providedIn: 'root'})
export class Car {
  radio: Radio|undefined;

  // OK: inicializador de campo
  spareTyre = inject(Tyre);

  constructor() {
    // OK: corpo do constructor
    this.radio = inject(Radio);
  }
}
```

Também é legal chamar [`inject`](api/core/inject) de uma factory de provider:

```typescript
providers: [
  {provide: Car, useFactory: () => {
    // OK: uma factory de classe
    const engine = inject(Engine);
    return new Car(engine);
  }}
]
```

Chamadas à função [`inject`](api/core/inject) fora da criação da classe ou `runInInjectionContext` resultarão em erro. Notavelmente, chamadas a `inject()` não são permitidas após uma instância de classe ser criada, em métodos (incluindo lifecycle hooks):

```typescript
@Component({ ... })
export class CarComponent {
  ngOnInit() {
    // ERRO: muito tarde, a instância do component já foi criada
    const engine = inject(Engine);
    engine.start();
  }
}
```

## Depurando o erro

Trabalhe de trás para frente a partir do stack trace do erro para identificar um local onde a chamada não permitida a `inject()` está localizada.

Para corrigir o erro, mova a chamada [`inject`](api/core/inject) para um local permitido (geralmente um constructor de classe ou um inicializador de campo).

**NOTA:** Se você está executando em um contexto de teste, `TestBed.runInInjectionContext` permitirá que `inject()` seja bem-sucedido.

```typescript
TestBed.runInInjectionContext(() => {
   // ...
});
```
